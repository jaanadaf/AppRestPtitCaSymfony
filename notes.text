SOMMAIRE DU PROJET SYMFONY

DEVELOPPER LA PARTIE BACK END D'UNE APPLICATION
====>Préparer l'envirennement et la création d'un projet symfony
-Installation d’une stack AMP : Apache, MySQL, PHP
-Installer Apache2
- Installer MysQL
-Installer PHP
-Configurer la stack AMP
=====>Création d'un projet Symfony avec Composer
-structure des dossiers
-Fichiers important
-Lancement de l'application
====> Développer sa première 
====> Aborder un nouveau projet
-Comprendre et modéliser le brief client
-Introduction à la méthode Merise
=====>Introduction à Doctrine
-Installer Doctrine
-Configurer Doctrine avec le fichier .env
===>Créer notre première table
===>CREER NOTRE PREMIRE TABLE
-Créer un entité Doctrine
-Migrer votre entité en base
===>CREER ET LIER NOS AUTRES ENTITES
-Lier vos entités avec des relations
-La relation 1-1, One-To-One
-La relation 1-n / n-1, One-To-Many / Many-To-One
-La relation n-n / Many-To-Many
===>Mettre en place l'interface utilisateur
contenu
-Créer un controller
-Créer une route
-Configurer une route
===>Mettre en place un CRUD


=============================================================================
CREATION DU PROJET SYMFONY AVEC Composer
Avant de commencer à installer un projet Symfony, il faut connaître deux choses essentielles. La première, c'est qu'on a besoin d'un gestionnaire de dépendances, 
ici ce sera Composer. Composer est un gestionnaire qui permet d’installer les dépendances en PHP.

Qu'est-ce qu'une dépendance ou un composant ?
Il s'agit simplement d’un dossier public sur GitHub par exemple, souvent open source, contenant des classes en PHP et d'autres fichiers (configuration, arborescence, etc.).
 Grâce à Composer, on va pouvoir télécharger ces fichiers et les inclure dans notre projet. Cela nous évite de "réinventer la roue" en réutilisant les classes créées par d'autres,
  pour la connexion, l'inscription, l'envoi d’e-mails, etc. C’est un des grands avantages de Symfony, qui nous permet de gagner du temps en développement.

Pour installer Symfony, j'ai besoin de Composer, mais aussi d'un binaire appelé Symfony CLI (Command Line Interface) qui ajoute des outils supplémentaires que Composer seul ne propose pas.
 Par exemple, Symfony CLI permet de vérifier l’environnement de l'ordinateur pour s’assurer qu’il peut supporter un projet Symfony et de gérer le déploiement en ligne. 
 Pour installer Symfony CLI, il suffit de se rendre sur la page officielle (symfony.com/download) et de suivre les instructions pour Linux, macOS ou Windows.

Composer doit aussi être installé :
Sous Windows, il faut télécharger et exécuter le binaire depuis le site officiel de Composer. Sur Linux et macOS, une commande terminal suffit (brew install composer pour macOS).

Une fois les deux binaires installés, en tapant symfony ou composer dans le terminal, vous verrez toutes les commandes disponibles. Sur Windows, ouvrez l'invite de commande (Windows + R, puis tapez cmd) 
et entrez les commandes.

Pour vérifier la compatibilité du système, la commande symfony check:requirements est très utile. Elle vérifie les extensions PHP nécessaires et la configuration, et s'assure qu'Apache est installé si besoin.

Créer un projet Symfony
Vous pouvez utiliser la commande symfony new <nom_du_projet> --version=5.4 --webapp ou composer create-project symfony/website-skeleton <nom_du_projet> "^5.4".
 La version 5.4 de Symfony est une LTS (Long Term Support) maintenue pendant 4 ans. Les versions plus récentes, comme 6.3 et 6.4, sont encore en développement et n'ont pas encore de support à long terme.

Dans Symfony, il existe deux types de bases de projet :

Skeleton - une base minimale pour démarrer.
Website Skeleton - une base plus complète avec des composants supplémentaires (Twig, Doctrine, etc.).
Structure du projet Symfony

bin/ : contient les binaires, notamment le fichier console, qui permet d’utiliser différentes commandes utiles durant le développement.
config/ : réunit tous les fichiers de configuration, aussi bien pour Symfony que pour les composants ajoutés avec Composer.
public/ : contient les ressources accessibles publiquement comme le JavaScript, les images, et la page d'accueil accessible via un navigateur.
src/ : le dossier principal de développement où se trouvent le code PHP, les routes, et la logique métier.
var/ : stockage des logs, du cache, et des sessions ; il est géré automatiquement par le serveur.
vendor/ : contient toutes les dépendances installées via Composer.
Les fichiers principaux

.env : pour stocker les informations de connexion à la base de données et d'autres configurations sensibles.
.env.local : version locale de .env qui n'est pas versionnée pour protéger les informations sensibles.
.gitignore : fichier de configuration pour Git permettant d’ignorer certains fichiers et dossiers à ne pas envoyer sur GitHub.
Cette structure offre une base solide pour un développement efficace et une bonne gestion de la configuration.
============================================================================================================================
DEVELOPPER SA PREMIERE page
Structure du Projet - Création de la Première URL
Dossier de Travail
Nous sommes maintenant sur notre projet RestaurantPtitCa. Pour commencer, accédez au dossier src, où nous développerons la logique métier du projet. À l’intérieur, vous trouverez deux éléments principaux :

Controller : où nous écrirons notre code.
Kernel : fichier de base, premier point d’entrée lorsque la requête arrive dans index.php, situé dans le dossier public.
Rôle de Kernel
Le fichier index.php reçoit les requêtes d'Apache, crée une instance de Kernel, qui lui-même charge les configurations du projet et initialise tous les fichiers nécessaires.

Création d'une Classe Contrôleur
Dans le dossier src, le répertoire Controller contiendra notre logique de contrôle. Nous allons y créer une classe en PHP nommée DefaultController.

Organisation des Noms
Notre projet utilise la convention PSR-4 pour les noms d’espaces (namespace). En PHP, les classes de contrôleurs suivent le standard "PascalCase", c’est-à-dire que chaque mot commence par une majuscule.

Dans notre cas, la classe s’appellera donc DefaultController et utilisera le namespace App\Controller. Ce namespace est défini automatiquement par Symfony, car src est équivalent à App dans le fichier composer.json.

Héritage de la Classe AbstractController
Pour que DefaultController soit un contrôleur, elle doit hériter de la classe AbstractController. Cette dernière se trouve dans Symfony\Bundle\FrameworkBundle\Controller, 
dans le dossier vendor. Elle nous fournit des méthodes pratiques, comme la redirection, l’envoi de JSON, et bien d'autres.

Création d'une Méthode dans le Contrôleur
À l'intérieur de DefaultController, créons une fonction publique nommée home. Elle renverra une réponse à l’utilisateur, qui, dans ce cas, sera un simple message "Bonjour".

Gestion des Noms de Classes et de Méthodes
Assurez-vous d’utiliser le namespace Symfony\Component\HttpFoundation\Response pour la classe Response, afin d’éviter les conflits avec d'autres classes portant le même nom.

Lier la Route à la Méthode
Pour associer l'URL à notre fonction home, nous utiliserons des annotations (ou des attributs en PHP 8). Voici la syntaxe de base :

php
Copier le code
use Symfony\Component\Routing\Annotation\Route;

class DefaultController extends AbstractController
{
    /**
     * @Route("/", name="home")
     */
    public function home(): Response
    {
        return new Response("Bonjour");
    }
}
Ici, nous avons défini une route "/" sans paramètres requis, sans options de sécurité, et sans méthode HTTP spécifique.

Démarrer le Serveur
Pour voir le résultat de notre travail, démarrons le serveur Symfony en exécutant la commande suivante :

bash
Copier le code
symfony server:start
Le serveur tournera sur http://127.0.0.1:8000. En accédant à cette adresse, vous verrez la réponse "Bonjour".

Accéder à une Autre Route
Si nous ajoutons une nouvelle route, par exemple /toto, il nous faudra actualiser l'URL pour voir la nouvelle réponse associée.

Conclusion
Nous avons créé notre première route associée à la racine de notre site. À l'avenir, la méthode home pourra renvoyer d'autres types de réponses, comme du HTML via Twig, ou du JSON dans le cadre d'une API.
============================================================================================
Introduction :

Aujourd'hui, nous sommes réunis pour une nouvelle vidéo où nous allons aborder la création d'une base de données sous l'angle de la modélisation. Nous utiliserons les méthodes MERISE en partant du cahier des charges fourni avec le projet. Ce projet, nommé "Projet Restaurant", servira de fil rouge tout au long de ce cours.

Étapes de création de la base de données :

Analyse du cahier des charges
Avant toute chose, il est essentiel de bien comprendre le projet pour concevoir une base de données adaptée. Le cahier des charges détaille les différentes fonctionnalités et la logique métier du projet, comme :

Les utilisateurs du site : administrateurs et clients.
Les services offerts, comme la réservation de tables.
Les informations spécifiques requises, comme les horaires d'ouverture, la capacité maximale de convives, les images du restaurant, etc.
Création de la table "Utilisateur" (User)
La table "Utilisateur" est essentielle pour enregistrer les informations des administrateurs et des clients :

Champs requis : prénom, nom, adresse email, mot de passe sécurisé.
Rôles : client ou administrateur.
Autres informations : nombre de convives, mention d’allergies, etc.
Le champ "Roles" permet de distinguer les administrateurs des clients. Le nombre de convives et les allergies sont nécessaires pour le service de réservation.

Informations du restaurant
Pour gérer les informations du restaurant, nous inclurons :

Les horaires d'ouverture et de fermeture sous forme de colonnes.
La capacité maximale de convives (champ "max_guest").
Une galerie d’images avec un titre, un lien vers la photo, et des dates de création et de mise à jour.
Gestion de la carte du restaurant
La carte du restaurant sera structurée en plusieurs tables :

Table "Catégorie" : pour différencier les types de plats (entrée, dessert, plat, etc.).
Table "Plat" : avec des champs pour le titre, la description et le prix.
Table "Menu" : incluant les plats associés.
Module de réservation
La réservation permettra aux clients de renseigner :

Le nombre de couverts souhaités.
La date et l'heure de la réservation.
D'éventuelles allergies.
Conception et optimisation de la base de données
La conception de la base de données est une étape cruciale pour la performance du projet. Une bonne organisation des tables et des relations entre elles évite les pertes de performance et facilite les requêtes SQL nécessaires au fonctionnement de l'application.

Modélisation avec la méthode MERISE :

Nous utiliserons la méthode MERISE pour structurer notre base de données en plusieurs modèles :

Modèle Conceptuel de Données (MCD) : pour identifier les entités et leurs relations.
Modèle Logique de Données (MLD) : pour définir les types de données et les clés primaires/étrangères.
Modèle Physique de Données (MPD) : pour traduire la structure en code SQL.
Des outils comme Open ModelSphere, Draw.io, ou Quick Database Diagrams peuvent être utilisés pour la modélisation. Ces outils permettent de visualiser les tables, les relations, et d'exporter le schéma final en SQL.

Conclusion :

Pour notre projet de restaurant, la base de données est l'élément fondamental. Elle doit être bien conçue dès le départ pour éviter des complications futures. La méthode MERISE et les outils de modélisation facilitent la visualisation et l'optimisation de la structure des tables.
===================================================================================================================
LANGUATION SQL DE LA TABLE 
User 
-
  id pk int
  uuid CHAR(36)
  firstName varchar(32)
  lastName varchar(64)
  email varchar(64) 
  password varchar(255) 
  roles json 
  guestNumber smallInt?
  allergies varchar(255)?
  createdAt dateTime
  update dateTime


Restaurant
-
 id PK int
 uuid CHAR(36)
  name varchar(32)
  description Longtext
  amOpeningtime json
  pmOpeningtime json
  maxguest smallInt?
  createdAt dateTime
  update dateTime
  Owner ONE_TO_ONE FK >- User.id
  
Picture
-
  id PK int
  titre CHAR(128)
  slug CHAR(128)
  createdAt dateTime
  update dateTime
  Restaurant MANY_TO_ONE FK >- Restaurant.id
==============================================================================================================================
EXPLICATION DU CODE 

Voici une explication détaillée de chaque table et champ dans votre code SQL pour User, Restaurant, et Picture :

Table User
Cette table contient des informations sur les utilisateurs, probablement des clients ou des propriétaires de restaurant.

id : Identifiant unique de l'utilisateur (clé primaire).
uuid : Identifiant unique universel (UUID) de 36 caractères, souvent utilisé pour identifier les utilisateurs de manière sécurisée et éviter les conflits d'ID.
firstName : Prénom de l'utilisateur, avec une limite de 32 caractères.
lastName : Nom de famille de l'utilisateur, avec une limite de 64 caractères.
email : Adresse e-mail de l'utilisateur, avec une limite de 64 caractères. Doit être unique pour chaque utilisateur.
password : Mot de passe de l'utilisateur, stocké sous forme de chaîne cryptée avec une longueur maximale de 255 caractères.
roles : Stocke les rôles de l'utilisateur dans un format JSON, permettant d'attribuer plusieurs rôles (par exemple, ROLE_USER, ROLE_ADMIN).
guestNumber : Nombre de personnes pour lesquelles l'utilisateur peut effectuer une réservation. C'est un nombre entier de petite taille (smallInt) qui peut être nul (?).
allergies : Informations sur les allergies de l'utilisateur, sous forme de chaîne de caractères de 255 caractères maximum, également optionnelle (?).
createdAt : Date et heure de création de l'enregistrement de l'utilisateur.
update : Date et heure de la dernière mise à jour de l'enregistrement de l'utilisateur.
Table Restaurant
Cette table stocke des informations sur les restaurants.

id : Identifiant unique du restaurant (clé primaire).
uuid : Identifiant unique universel (UUID) pour chaque restaurant, permettant une identification unique.
name : Nom du restaurant, limité à 32 caractères.
description : Description longue du restaurant (type Longtext), pouvant contenir des informations détaillées.
amOpeningtime : Horaires d'ouverture du matin, stockés en JSON pour permettre une flexibilité dans les formats d'heures (ex. 09:00-12:00).
pmOpeningtime : Horaires d'ouverture de l'après-midi, également stockés en JSON.
maxguest : Nombre maximal de clients pouvant être accueillis dans le restaurant, un smallInt optionnel (?).
createdAt : Date et heure de création de l'enregistrement du restaurant.
update : Date et heure de la dernière mise à jour de l'enregistrement du restaurant.
Owner : Relation de type ONE_TO_ONE vers un enregistrement dans la table User (via User.id), indiquant que chaque restaurant a un propriétaire unique.
Table Picture
Cette table gère les images associées aux restaurants, comme les photos d'ambiance ou de plats.

id : Identifiant unique de chaque image (clé primaire).
titre : Titre ou nom de l'image, limité à 128 caractères.
slug : Identifiant unique pour chaque image, souvent utilisé pour les URLs, également limité à 128 caractères.
createdAt : Date et heure de création de l'image.
update : Date et heure de la dernière mise à jour de l'image.
Restaurant : Relation MANY_TO_ONE vers un enregistrement dans la table Restaurant (via Restaurant.id), indiquant qu'un restaurant peut avoir plusieurs images associées.
Relations entre les tables
User et Restaurant : Relation ONE_TO_ONE avec Owner, signifiant qu'un restaurant a un propriétaire unique qui est un utilisateur, mais chaque utilisateur peut être propriétaire d'un seul restaurant.
Restaurant et Picture : Relation MANY_TO_ONE, indiquant qu'un restaurant peut être associé à plusieurs images, mais chaque image est liée à un seul restaurant.
En résumé, ces tables définissent un modèle pour une application de réservation de restaurant avec des informations sur les utilisateurs, les restaurants qu'ils possèdent, et les images associées à chaque restaurant.
============================================================================================
INTRODUCTION A Doctrine
INSTALLATION A Doctrine
symfony check:requirements
symfony new my_project_directory --version="5.4.*"
composer require symfony/orm-pack
composer require --dev symfony/maker-bundle
composer update
===================================================================================
CONFIGURER Doctrine AVEC LE FICHIER .env

Introduction
Bonjour, aujourd'hui, nous allons voir comment configurer globalement votre projet Symfony à partir de certains fichiers essentiels. Nous aborderons également la création d'une base de données via Symfony en ligne de commande, ainsi que la création des tables et d'autres éléments dans les cours suivants. L'objectif est de configurer votre projet Symfony de manière à ce qu'il puisse communiquer avec une base de données SQL.

Configuration de la connexion à la base de données
Pré-requis :

Assurez-vous d'avoir MySQL (version 8 minimum) installé sur votre système.
La connexion à MySQL se fait via un utilisateur et un mot de passe spécifiques que vous devez bien retenir, car nous en aurons besoin pour configurer la connexion à la base de données.
Fichier .env :

Ce fichier contient les variables d’environnement de votre projet, comme les identifiants de connexion à la base de données. Cependant, étant donné que .env est versionné (suivi par Git), toute modification y est enregistrée, ce qui peut poser un problème de sécurité si des informations sensibles, comme des mots de passe, sont exposées.
Sécuriser les variables sensibles :

Pour éviter cela, nous allons utiliser un fichier .env.local, qui surcharge les valeurs du fichier .env mais n'est pas suivi par Git. Ainsi, vous pouvez y placer vos informations confidentielles en toute sécurité.
Exemple de connexion avec MySQL
Dans le fichier .env, définissez une variable DATABASE_URL sans les informations sensibles. Ensuite, dans le fichier .env.local, ajoutez les valeurs exactes, comme l'utilisateur, le mot de passe et le nom de la base de données. Par exemple :

env
Copier le code
DATABASE_URL="mysql://utilisateur:mot_de_passe@127.0.0.1:3306/nom_base_de_donnees"
Création de la base de données avec Symfony
Commandes :
Pour créer la base de données, utilisez la commande suivante dans le terminal :
bash
Copier le code
php bin/console doctrine:database:create
Cette commande vérifiera si les informations dans DATABASE_URL permettent de créer la base de données.
Vérification de la création :
Pour vérifier si la base de données a bien été créée, vous pouvez utiliser MySQL avec la commande SHOW DATABASES; ou un outil comme PHPMyAdmin.
Suppression de la base de données
Pour supprimer la base de données, exécutez la commande :

bash
Copier le code
php bin/console doctrine:database:drop --force
Cette option --force est nécessaire pour confirmer la suppression, car c'est une action irréversible.

Conclusion
En suivant ces étapes, vous avez appris à configurer la connexion à une base de données de manière sécurisée et à créer la base de données via Symfony en ligne de commande.
=================================================================
CREER NOTRE PREMIRE TABLE
Créer un entité Doctrine
Migrer votre entité en base
==================================================================
CREER ET LIER NOS AUTRES ENTITES

-Lier vos entités avec des relations
Pour l’instant, Doctrine vous permet de créer des entités, de les mapper et d’interagir simplement avec vos données. À ce stade, vous êtes en mesure de créer une table indépendante « Restaurant », et pourquoi pas une table « Picture ». Mais comment lier mes tables entre elles ? Comment peut-on jouer avec nos données ? Par exemple, admettons qu’un utilisateur souhaite sortir tous les produits d’une certaine catégorie ?

C’est ce qu’on appelle une « relation ». Et pour cela, il est crucial de comprendre les 3 types de relations possibles entre les entités. Le type de relation mis en place est relativement important, car il impactera directement la performance de l’application et la façon dont le code fonctionnel sera écrit.
Une relation 1 pour 1 fait référence à une association entre deux entités où chaque enregistrement dans la première entité est lié à un seul enregistrement dans la deuxième entité, et vice versa.

Mais comment traduire cela en SQL ? Eh bien, une des entités (l’entité « propriétaire ») contiendra une clé étrangère qui fera référence à l’entité associée.
-La relation 1-1, One-To-One
Une relation 1 pour 1 fait référence à une association entre deux entités où chaque enregistrement dans la première entité est lié à un seul enregistrement dans la deuxième entité, et vice versa.

Mais comment traduire cela en SQL ? Eh bien, une des entités (l’entité « propriétaire ») contiendra une clé étrangère qui fera référence à l’entité associée.
-La relation 1-n / n-1, One-To-Many / Many-To-One
Une relation 1 pour plusieurs (aussi plusieurs pour 1) est la relation la plus courante.

Elle fait référence à une association entre deux entités où chaque enregistrement dans la première entité peut être associé à plusieurs enregistrements d’une autre entité.

Et en SQL ?

L’entité du côté Many contiendra toujours la clé étrangère qui fera référence à l’entité associée.

Par exemple : nous avons une entité « Ecole » qui peut avoir plusieurs « Eleve ».

Alors nous avons Many « Eleve » to One « Ecole ». La clé étrangère sera donc du côté « Eleve 
-La relation n-n / Many-To-Many
À l’inverse de la Many To One, cette relation Many To Many nous sert si des enregistrements font références à plusieurs autres enregistrements.

Reprenons le cas précédent des objets « Ecole » et « Eleve ».

Si nos « Eleve » seraient en même temps dans une autre « Ecole » (admettons qu’ils sont dans une école nommée A certains jours et dans une autre école nommée B d’autres jours), il nous faudra retenir en SQL qu’un « Eleve » peut-être dans l’école A, mais également dans l’école B. Et que chaque « Ecole » puisse avoir plusieurs élèves.

Pour cela, Doctrine va créer une table de jointure, nommée « ecole_eleve » qui contiendra les colonnes suivantes :

ecole_id : cette colonne stocke l’identifiant de l’école pour chaque lien entre une école et un élève. Elle est une clé étrangère qui fait référence à la clé primaire de la table école.

eleve_id : cette colonne stocke l’identifiant de l’élève pour chaque lien entre une école et un élève. Elle est une clé étrangère qui fait référence à la clé primaire de la table élève.

Chaque ligne dans cette table de jointure représente une association entre une « Ecole » et un « Eleve ». Donc, si un « Eleve » appartient à plusieurs « Ecole », il y aura plusieurs lignes pour cet « Eleve » dans la table de jointure.

Il est important de noter que Doctrine gère automatiquement la création et la maintenance de cette table de jointure pour vous.

À comprendre également, que ce n’est pas parce qu’une table supplémentaire de jointure a été ajoutée par Doctrine, qu’une entité en plus sera créée.
===================================================================
Gestion des Relations entre Entités avec Doctrine et Enregistrement en Base de Données

Création des Entités
Nous avons d'abord créé une entité Restaurant avec plusieurs attributs représentant différents champs. Cette entité est accompagnée d'une classe Repository qui facilite l'accès aux données via des méthodes comme findBy ou findOneBy. Cela permet de récupérer des informations spécifiques et de créer des méthodes personnalisées pour interagir avec l'entité Restaurant.

Ajout d'une Nouvelle Entité et des Relations
Une seconde entité Picture a été ajoutée pour modéliser des images associées à un restaurant. Cette entité inclut des champs tels que le titre, le slug (une chaîne unique), et des dates de création et de mise à jour. Une fois cette entité créée, une migration est générée pour refléter ces changements dans la base de données.

Création des Relations
Nous établissons une relation OneToMany entre Restaurant et Picture, car un restaurant peut être lié à plusieurs images. Cette relation est configurée à l'aide de Doctrine, en ajoutant une foreign key dans l’entité Picture pour référencer l’entité Restaurant. Ainsi, depuis l'entité Restaurant, nous pourrons accéder à toutes les images associées via une collection d'objets Picture.

Types de Relations en Doctrine
Nous avons discuté des différents types de relations :

OneToOne : Utilisée lorsque chaque instance d'une entité est liée à une seule instance d'une autre entité.
OneToMany / ManyToOne : Permet à une entité d'être liée à plusieurs instances d'une autre entité (cas de Restaurant et Picture).
ManyToMany : Utilisée lorsqu'une entité peut être associée à plusieurs instances d'une autre entité, et inversement (ex. : catégorie et produit).
Ajout des Champs Relationnels et Migrations
Après la définition des relations, une migration est générée pour mettre à jour le schéma de la base de données. Cela crée la foreign key qui relie les tables Restaurant et Picture. La commande php bin/console make:migration génère une migration SQL, et php bin/console doctrine:migrations:migrate exécute les changements en base.

Insertion et Test des Relations en Base de Données
Nous avons inséré un enregistrement Restaurant et plusieurs Picture, associant ces images au restaurant via le champ relationnel. Doctrine nous permet d'utiliser les relations établies pour récupérer les images d'un restaurant ou l'inverse.

Ce texte structuré présente une explication claire et ordonnée de la gestion des relations entre les entités Restaurant et Picture avec Doctrine, en incluant la création d'entités, de relations, et les tests de la base de données.
==================================================================================================
Mettre en place un CRUD
1. Introduction
Dans ce cours, nous allons créer des contrôleurs pour interagir avec la base de données d'un restaurant. Nous avons déjà une entité Restaurant et une relation avec l'entité Picture, permettant d'avoir plusieurs images associées à un restaurant. Nous avons également effectué la migration de la base de données SQL, qui contient ces entités.

Objectifs :
Créer un contrôleur pour gérer les routes liées aux restaurants.
Interagir avec la base de données via ces routes.
2. Création du Contrôleur Restaurant
a. Structure du Contrôleur
Un contrôleur est une classe PHP qui est responsable de la gestion des requêtes HTTP et de l'interaction avec les modèles de données (entités, base de données). Les contrôleurs sont généralement situés dans le dossier src/Controller.

Étapes pour créer un contrôleur :
Manuellement ou via Symfony Maker Bundle :

Vous pouvez créer un contrôleur à la main ou utiliser le Maker Bundle pour générer automatiquement le code du contrôleur.
Commande pour générer un contrôleur avec Maker Bundle :

Installez d'abord le Maker Bundle si ce n'est pas déjà fait avec la commande suivante :
bash
Copier le code
composer require symfony/maker-bundle
Ensuite, générez le contrôleur avec cette commande :
bash
Copier le code
php bin/console make:controller RestaurantController
Cela crée un fichier RestaurantController.php dans le dossier src/Controller.

3. Structure de RestaurantController.php
Le fichier RestaurantController.php contient une classe qui étend la classe AbstractController. Voici une vue d'ensemble de ce que contiendra le contrôleur :

a. Imports nécessaires
php
Copier le code
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
b. Définition des Routes
Un contrôleur expose des méthodes qui sont liées à des routes spécifiques. Par exemple :

php
Copier le code
/**
 * @Route("/restaurant", name="restaurant_index")
 */
public function index(): Response
{
    return $this->json(['message' => 'Welcome to the restaurant controller!']);
}
Cette méthode index renverra une réponse JSON lorsque vous accédez à /restaurant.

4. Tests de la Route
a. Lancer le Serveur Symfony
Pour tester votre contrôleur et voir si la route fonctionne, lancez le serveur Symfony local avec la commande :

bash
Copier le code
symfony server:start
Cela démarre un serveur local sur le port 8000.

b. Accéder à la Route
Accédez à l'URL suivante dans votre navigateur :

bash
Copier le code
http://localhost:8000/restaurant
Vous devriez voir le message JSON : {"message": "Welcome to the restaurant controller!"}.

5. Création de Méthodes et Routes supplémentaires
Maintenant que la route de base fonctionne, vous pouvez créer des méthodes supplémentaires pour ajouter, modifier ou supprimer des restaurants. Par exemple :

a. Ajouter un Nouveau Restaurant
php
Copier le code
/**
 * @Route("/restaurant/new", name="restaurant_new", methods={"POST"})
 */
public function new(Request $request): Response
{
    // Code pour ajouter un restaurant
}
Cette route accepte uniquement les requêtes POST.
Vous pouvez ensuite récupérer les données du corps de la requête via $request->get('data').
b. Récupérer un Restaurant
php
Copier le code
/**
 * @Route("/restaurant/{id}", name="restaurant_show", methods={"GET"})
 */
public function show(int $id): Response
{
    // Code pour récupérer et afficher un restaurant
}
Cette méthode récupère un restaurant par son id.
c. Modifier un Restaurant
php
Copier le code
/**
 * @Route("/restaurant/{id}/edit", name="restaurant_edit", methods={"PUT"})
 */
public function edit(int $id, Request $request): Response
{
    // Code pour modifier un restaurant
}
La méthode PUT permet de mettre à jour un restaurant existant.
6. Conclusion et Récapitulatif
Vous avez créé un contrôleur pour gérer les restaurants et leurs images.
Vous avez testé et validé les routes définies pour gérer l'ajout, la modification et la suppression des restaurants.
Ces routes interagissent avec la base de données via les entités Restaurant et Picture.
Vous pouvez maintenant étendre ce contrôleur pour ajouter plus de fonctionnalités selon les besoins de votre application.

Cela donne une vision claire et structurée des étapes à suivre pour créer des contrôleurs et interagir avec la base de données dans Symfony.






Vous avez dit :
vous avez oublié delete
ChatGPT a dit :
ChatGPT
Vous avez raison, j'ai omis la méthode pour supprimer un restaurant. Voici la méthode delete pour supprimer un restaurant de la base de données.

7. Suppression d'un Restaurant
Pour ajouter la possibilité de supprimer un restaurant, vous pouvez définir une route qui accepte une requête DELETE. Cette méthode sera utilisée pour supprimer un restaurant en fonction de son id.

a. Méthode delete dans le contrôleur
php
Copier le code
/**
 * @Route("/restaurant/{id}", name="restaurant_delete", methods={"DELETE"})
 */
public function delete(int $id): Response
{
    // Récupérer le restaurant à supprimer
    $restaurant = $this->getDoctrine()->getRepository(Restaurant::class)->find($id);

    // Vérifier si le restaurant existe
    if (!$restaurant) {
        return $this->json(['message' => 'Restaurant not found'], Response::HTTP_NOT_FOUND);
    }

    // Supprimer le restaurant
    $entityManager = $this->getDoctrine()->getManager();
    $entityManager->remove($restaurant);
    $entityManager->flush();

    // Retourner une réponse indiquant la suppression
    return $this->json(['message' => 'Restaurant deleted successfully'], Response::HTTP_NO_CONTENT);
}
====>create
1. Lister les routes existantes
Lorsque vous exécutez la commande suivante :

bash
Copier le code
php bin/console debug:router
Vous pouvez visualiser toutes vos routes définies, avec leur méthode HTTP et leur URL associée, comme :

GET /api/restaurant : Afficher les restaurants.
POST /api/restaurant : Ajouter un nouveau restaurant.
GET /api/restaurant/{id} : Afficher un restaurant spécifique.
DELETE /api/restaurant/{id} : Supprimer un restaurant.
C'est un bon point de départ pour vérifier que vos routes sont bien configurées.

2. Vérification initiale avec des réponses simples
Avant de connecter vos routes à la base de données, vous pouvez leur associer des réponses simples pour tester leur comportement.

Exemple pour la route GET /api/restaurant :
Ajoutez un retour JSON statique dans votre contrôleur pour tester la route :

php
Copier le code
/**
 * @Route("/api/restaurant", name="get_restaurants", methods={"GET"})
 */
public function getRestaurants(): JsonResponse
{
    return $this->json([
        'message' => 'Route fonctionne',
        'data' => [],
    ], Response::HTTP_OK);
}
3. Créer des objets en dur avant de les connecter à la base
Pour la route POST /api/restaurant, commencez par créer un objet en dur avant d'ajouter la logique pour interagir avec Doctrine.

Exemple avec un objet statique :
php
Copier le code
/**
 * @Route("/api/restaurant", name="add_restaurant", methods={"POST"})
 */
public function addRestaurant(): JsonResponse
{
    $restaurant = [
        'name' => 'Le Gourmet',
        'description' => 'Un restaurant avec des plats de qualité exceptionnelle.',
        'created_at' => new \DateTime(),
    ];

    return $this->json([
        'message' => 'Restaurant créé',
        'data' => $restaurant,
    ], Response::HTTP_CREATED);
}
4. Connecter les routes à la base de données
Une fois les tests réussis, vous pouvez lier vos routes à Doctrine pour interagir avec votre base.

Route POST /api/restaurant avec Doctrine :
Voici comment enregistrer un restaurant en base :

php
Copier le code
/**
 * @Route("/api/restaurant", name="add_restaurant", methods={"POST"})
 */
public function addRestaurant(Request $request, ManagerRegistry $doctrine): JsonResponse
{
    $data = json_decode($request->getContent(), true);

    // Valider les données reçues
    if (!isset($data['name']) || !isset($data['description'])) {
        return $this->json(['message' => 'Données manquantes'], Response::HTTP_BAD_REQUEST);
    }

    // Créer un nouvel objet Restaurant
    $restaurant = new Restaurant();
    $restaurant->setName($data['name']);
    $restaurant->setDescription($data['description']);
    $restaurant->setCreatedAt(new \DateTime());

    // Sauvegarder en base
    $entityManager = $doctrine->getManager();
    $entityManager->persist($restaurant);
    $entityManager->flush();

    return $this->json([
        'message' => 'Restaurant créé',
        'data' => [
            'id' => $restaurant->getId(),
            'name' => $restaurant->getName(),
            'description' => $restaurant->getDescription(),
        ],
    ], Response::HTTP_CREATED);
}
5. Tester les fonctionnalités
Tester avec Postman ou cURL :
Méthode : POST
URL : http://localhost:8000/api/restaurant
Body :
json
Copier le code
{
    "name": "Le Gourmet",
    "description": "Un restaurant avec des plats de qualité exceptionnelle."
}
Réponse attendue :
json
Copier le code
{
    "message": "Restaurant créé",
    "data": {
        "id": 1,
        "name": "Le Gourmet",
        "description": "Un restaurant avec des plats de qualité exceptionnelle."
    }
}
6. Prochaine étape : rendre les méthodes dynamiques
Pour la route GET /api/restaurant, récupérez tous les restaurants depuis la base.
Pour la route GET /api/restaurant/{id}, récupérez un restaurant spécifique.
Pour la route DELETE /api/restaurant/{id}, supprimez un restaurant.
===>READ
Étant donné que nous pouvons ajouter des « Restaurants » au sein de notre base via Doctrine, il nous faut maintenant la possibilité de voir chaque « Restaurant » par son attribut $id, en lui passant celui-ci en paramètre de l’URL.

Également, il nous faudra son repository « RestaurantRepository » pour aller chercher l’entité en base avec son $id, via la méthode « ->find($id) » ;

CTRL+C pour copier, CTRL+V pour coller
1
<?php
2
3
// …
4
5
    #[Route('/{id}', name: 'show', methods: 'GET')]
6
    public function show(int $id): Response
7
    {
8
        $restaurant = $this->repository->findOneBy(['id' => $id]);
9
10
        if (!$restaurant) {
11
            throw $this->createNotFoundException("No Restaurant found for {$id} id");
12
        }
13
14
        return $this->json(
15
            ['message' => "A Restaurant was found : {$restaurant->getName()} for {$restaurant->getId()} id"]
16
        );
17
    } 
18
19
// …
Notre condition if sert à s’assurer que l’objet « Restaurant » sélectionné existe bien en base sinon une erreur en JSON est renvoyée.

Chacun des types HTTP correspond aux standards RESTful et vous sera expliqué lors de la mise en API.
=================================================================================
DELETE
1. Gestion des routes avec paramètres dans l'URL
Les routes telles que /api/restaurant/{id} permettent de passer des arguments dynamiquement dans l'URL. Par exemple :

Quand tu accèdes à /api/restaurant/1, le paramètre {id} est automatiquement injecté dans la méthode grâce à Symfony.
Ce paramètre est ensuite utilisé pour chercher une ressource (exemple : un restaurant dans la base de données).
Exemple d'utilisation dans la méthode show :

php
Copier le code
$restaurant = $this->repository->find($id);
Cela récupère un restaurant ayant l'ID spécifié dans l'URL. Si aucun restaurant n'est trouvé, on peut lever une exception pour signaler une erreur.

2. Lever une exception si la ressource n'existe pas
Symfony propose plusieurs façons de lever des erreurs, comme :

throw new \Exception("Message d'erreur"); : une exception générique.
throw $this->createNotFoundException("Message d'erreur"); : une méthode spécifique à Symfony pour signaler qu'une ressource est introuvable (renvoie une réponse HTTP 404 par défaut).
Cela permet de gérer les cas où un restaurant est introuvable. Exemple :

php
Copier le code
if (!$restaurant) {
    throw $this->createNotFoundException("No Restaurant found for ID {$id}");
}
3. Mise à jour en base de données
Quand on modifie un objet, il faut signaler à Doctrine (l'ORM utilisé par Symfony) de sauvegarder les changements. Cela se fait avec :

$this->manager->persist($restaurant); : pour suivre l'entité modifiée.
$this->manager->flush(); : pour pousser les modifications dans la base de données.
Exemple dans la méthode edit :

php
Copier le code
$restaurant->setName('Nouveau nom');
$this->manager->flush();
Cela met à jour le champ name du restaurant dans la base.

4. Suppression d'une ressource
Pour supprimer un objet, on utilise :

$this->manager->remove($restaurant); : pour marquer l'objet à supprimer.
$this->manager->flush(); : pour effectuer la suppression en base.
Exemple dans la méthode delete :

php
Copier le code
$this->manager->remove($restaurant);
$this->manager->flush();
5. Retourner des données au format JSON
Symfony facilite le retour de données JSON, qui est le format standard pour les API REST. Voici deux exemples de retour JSON :

Retour d'un message simple :

php
Copier le code
return $this->json(['message' => "Restaurant found: {$restaurant->getName()} for ID {$restaurant->getId()}"]);
Ce code renvoie un message contenant uniquement des informations essentielles.

Retour d'une structure détaillée :

php
Copier le code
return $this->json([
    'id' => $restaurant->getId(),
    'name' => $restaurant->getName(),
    'description' => $restaurant->getDescription(),
    'createdAt' => $restaurant->getCreatedAt()->format('Y-m-d H:i:s'),
]);
Ce code renvoie une structure plus riche, souvent utilisée pour afficher des détails sur la ressource.

Résumé du workflow
On configure une route qui accepte des paramètres (/api/restaurant/{id}).
On injecte les dépendances nécessaires (EntityManager, RestaurantRepository) dans le contrôleur.
On cherche les données dans la base grâce au repository.
On gère les exceptions en cas de ressource introuvable.
On effectue des modifications en base avec persist et flush.
On renvoie une réponse JSON adaptée.
Si tu as d'autres questions ou si tu veux approfondir un aspect spécif

LA SUITE
1. Méthode GET (Récupérer des données) :
Lorsque vous effectuez une requête GET pour récupérer des ressources (comme un restaurant), le navigateur utilise cette méthode pour obtenir des informations à partir du serveur. Par exemple, en appelant une API pour obtenir un restaurant avec un ID spécifique, vous utilisez une requête de type GET dans Postman ou un navigateur :

Exemple :

URL : api/restaurant/1
Méthode : GET
Cela va appeler un contrôleur qui, via le Repository, récupère le restaurant par son ID à l'aide de la méthode findOneBy() :

php
Copier le code
$restaurant = $restaurantRepository->findOneBy(['id' => $id]);
Ensuite, vous retournez l'objet restaurant sous forme de réponse.

2. Méthode POST (Ajouter des données) :
Pour ajouter un nouveau restaurant à la base de données, vous utilisez une méthode POST. Cela nécessite de recevoir les données envoyées par le client (par exemple, via un formulaire) et de les insérer dans la base de données.

Exemple avec Postman :

URL : api/restaurant
Méthode : POST
Corps de la requête : un objet JSON contenant les informations du restaurant (nom, description, etc.).
En Symfony, vous utilisez un contrôleur qui récupère ces données, crée un nouvel objet Restaurant, puis l'enregistre dans la base de données :

php
Copier le code
$restaurant = new Restaurant();
$restaurant->setNom($nom);
$restaurant->setDescription($description);
// Autres propriétés...

$entityManager->persist($restaurant); // Pour enregistrer l'objet dans la base de données
$entityManager->flush(); // Pour appliquer les changements
Si tout se passe bien, vous obtenez une réponse HTTP 201 (Created) avec les données du restaurant.

3. Méthode PUT (Modifier des données) :
Pour modifier un restaurant existant, vous devez récupérer l'objet via son ID, puis mettre à jour ses propriétés. Une fois les modifications effectuées, vous enregistrez à nouveau l'objet dans la base de données.

Exemple avec Postman :

URL : api/restaurant/1
Méthode : PUT
Corps de la requête : un objet JSON avec les nouvelles valeurs du restaurant.
En Symfony, vous récupérez le restaurant existant, le modifiez, puis vous utilisez le flush() pour appliquer les changements :

php
Copier le code
$restaurant = $restaurantRepository->findOneBy(['id' => $id]);
if ($restaurant) {
    $restaurant->setNom($newNom);
    $restaurant->setDescription($newDescription);
    // Autres modifications...

    $entityManager->flush(); // Appliquer les changements
}
4. Méthode DELETE (Supprimer des données) :
Pour supprimer un restaurant de la base de données, vous récupérez d'abord l'objet par son ID, puis vous utilisez la méthode remove() sur l'EntityManager pour le supprimer.

Exemple avec Postman :

URL : api/restaurant/1
Méthode : DELETE
Le contrôleur Symfony correspond à :

php
Copier le code
$restaurant = $restaurantRepository->findOneBy(['id' => $id]);
if ($restaurant) {
    $entityManager->remove($restaurant);
    $entityManager->flush(); // Appliquer la suppression
}
5. Utilisation de Postman ou cURL :
Si vous voulez tester vos API sans passer par un navigateur, vous pouvez utiliser Postman pour envoyer des requêtes HTTP (GET, POST, PUT, DELETE).

Exemple avec cURL :
Si vous préférez utiliser la ligne de commande, vous pouvez utiliser cURL pour tester votre API. Par exemple, pour envoyer une requête POST :

bash
Copier le code
curl -X POST -H "Content-Type: application/json" -d '{"nom": "New Restaurant", "description": "Delicious food"}' http://localhost/api/restaurant
Conclusion :
Utilisez POSTMAN ou cURL pour tester vos requêtes API.
Les méthodes de requêtes (GET, POST, PUT, DELETE) permettent d'interagir avec votre base de données via Doctrine.
Utilisez find(), findOneBy() pour récupérer des objets, persist() et flush() pour les ajouter ou modifier, et remove() et flush() pour les supprimer.
==========================================================================================
===>HTTP
-Requête HTTP
-Réponse HTTP
INSTALLATION DE POSTMAN
Qu'est-ce qu'une API et pourquoi l'utiliser ?
Une API (Application Programming Interface) est une interface permettant d’échanger des données entre différentes applications.
L’architecture client-serveur est centrale :
Le client (ex. application mobile, site web, logiciel) envoie une requête.
Le serveur répond avec des données ou des informations spécifiques.
Les API sont essentielles pour :
Connecter des services.
Permettre l’accès sécurisé aux données grâce à des mécanismes comme les tokens.
Faciliter les interactions entre différentes technologies.
Types de requêtes HTTP fréquemment utilisées
GET : Récupérer des ressources (ex. une liste d'articles).
POST : Envoyer des données pour en créer de nouvelles (ex. enregistrer un utilisateur).
PUT/PATCH : Mettre à jour des ressources existantes (totalement ou partiellement).
DELETE : Supprimer une ressource.
Ces requêtes sont standardisées par des documents comme le RFC 2616.

Outils pour consommer une API
Postman :

Logiciel très utilisé pour tester et interagir avec les API.
Il permet de :
Créer des requêtes.
Tester les réponses du serveur.
Ajouter des paramètres (headers, body, tokens).
Sauvegarder des requêtes dans des collections.
Avantages :
Interface visuelle simple.
Compatible avec toutes les plateformes (Windows, Mac, Linux).
Astuce : Créez un compte Postman pour sauvegarder vos travaux dans le cloud.
Curl :

Utilitaire en ligne de commande pour effectuer des requêtes HTTP.
Exemple pour une requête POST :
bash
Copier le code
curl -X POST http://localhost:8000/api/resource -d '{"key":"value"}' -H "Content-Type: application/json"
Moins visuel, mais très utile pour automatiser les tests dans des scripts.
Exemple d’utilisation avec Postman
Tester une requête :

Sélectionnez le type de requête (GET, POST, etc.).
Ajoutez l’URL de l’API (ex. http://127.0.0.1:8000/api/resource).
Configurez les paramètres :
Headers : Ex. Authorization: Bearer <token> pour l’authentification.
Body : Contient les données pour une requête POST ou PUT, souvent au format JSON.
Cliquez sur Send pour envoyer la requête.
Analyser la réponse :

Code HTTP de la réponse (ex. 200 pour succès, 401 pour non autorisé).
Corps de la réponse (JSON, HTML, etc.).
Temps de réponse du serveur.
Sauvegarder et organiser vos requêtes :

Utilisez des collections pour regrouper des requêtes similaires.
Partagez ces collections avec votre équipe.
Bonnes pratiques pour les API
Stateless : Les API ne doivent pas conserver d’état entre les requêtes.
Authentification :
Utilisez des tokens (ex. JWT) plutôt que des cookies.
Activez les mécanismes de sécurité pour protéger vos données.
Documentation : Fournissez des exemples clairs d’utilisation avec des outils comme Swagger ou Postman.
Validation des données : Assurez-vous que les données reçues dans les requêtes sont valides.
Outils complémentaires
Swagger/OpenAPI : Génère automatiquement une documentation interactive pour vos API.
Postman Collections : Permet de partager des tests d’API avec vos collègues.
Environnements Postman : Configurez des variables dynamiques (URL, tokens) pour gagner du temps.
